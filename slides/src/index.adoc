= Type Driven User Interfaces: with [.yellow]#Qt# and [.yellow]#C++#
:author: Andreas Reischuck
:twitter: @arBmind
:!avatar: andreas.png
:!organization: HicknHack Software GmbH
:!sectids:
:imagesdir: images
:icons: font
:use-link-attrs:
:title-separator: :
:codedir: code
:data-uri:

*Qt World Summit 2019 Berlin*

++++
<svg class="overlay build" viewBox="0 0 1280 720" width="1920" height="1080">
    <g transform="translate(610,260) scale(3) rotate(10)">
        <text class="cppVersion build" x="0" y="0">17</text>
    </g>
</svg>
++++

[.cue]
****
Welcome

Goals of this talk:

* Go play with C++ / hacken?
* Increase understanding - What is what?
* Not Important - Use this next week.

Hopefully for everybody I have something unknown!
****

[.subtitle]
== What is a type?

[.cue]
****
It depends on who you ask?
****

== What is a type?: …for the CPU

[%build]
* Understanding the bits
* How to compute on bits
* Alignment

[.cue]
****
* Hardware / Interpretation of Bits
* Float vs Int vs SSE
****

== What is a type?: …for a Compiler

[%build]
* Aggregate
* Amount of bytes
* Lifecycle

[.cue]
****
* Classes, Arrays, … (Memory layout)
* Protection against accidental misuse
****

== What is a type?: …for the developer

[%build]
* Architectural entities
* Semantics
* Functions

[.cue]
****
* Guidance for structuring code
* APIs / Management
* Controller / Repositories
****

== !

[.canvas]
image::Zirkelstein.jpg[]

[.cue]
****
* Ok, I hope you can follow my story
* Now, get to C++
****


[.subtitle]
== Strong Types

[.cue]
****
* Let's implement simple strong types

To motivate this let's look at the issue…
****

[.source.s62x16]
== !

[.build]
--
[source%nested, cpp, subs=quotes,macros]
----
using Distance = double; // Alias
// nest++
auto d = Distance{3} + 2; // [.green]##Ok##: just double
// nest--

// nest++
using Velocity = Strong&lt;double, struct VelocityTag>;
// nest--
// nest++
auto v = Velocity{3} + 2; // [.red]##Error##: no operator
// nest--
----
--

[.cue]
****
* Type alias create no boundaries

But a tagged template creates a unique type

How might the simplest implementation look like?
****

[.source]
== !

[.build]
--
[source%nested, cpp, subs=quotes,macros]
----
template&lt;class V, class... /\*Tags*/>
struct Strong {
    // nest++
    [.token.class-name]##V## v{};
    // nest--
};
----
--

[.cue]
****
* The template signature: base type and any amount of tags
* Inside we store just the value

You might want to add operators, but that's enough for this talk.

If you want to learn more about strong types…
****

== !

image::BarneyDellar_StrongTypes_CppOnSea.png[role="center", width="1280"]

link:https://www.youtube.com/watch?v=fWcnp7Bulc8[Strong Types in C++ - Barney Dellar [C++ on Sea 2019]]

[.cue]
****
There are a lot of good talks and blog posts.

If you want to stick to standard take a look at <chronos>.

****


== Type Driven Applications

[%build]
* imagine a distributed system
* (note: still slide example)

== !

++++
<!-- for editing help:
 * https://editor.method.ac
 * https://svg-edit.github.io/svgedit/releases/latest/editor/svg-editor.html
-->
<svg class="build" viewBox="0 0 1280 720" width="1920" height="1080">
    <defs>
        <filter id="dropshadow" height="130%" width="130%">
            <feGaussianBlur in="SourceAlpha" stdDeviation="5"/>
            <feOffset dx="0" dy="0" result="offsetblur"/>
            <feComponentTransfer>
                <feFuncA type="linear" slope="0.5"/>
            </feComponentTransfer>
            <feMerge> 
                <feMergeNode/>
                <feMergeNode in="SourceGraphic"/>
            </feMerge>
        </filter>
        <rect id="activeRect" x="2%" y="2%" width="96%" height="96%" fill="#fff" rx="20" ry="20" fill-opacity="0" stroke="#8da" stroke-width="15" />
        <filter id="activeMarker" filterUnits="objectBoundingBox">
            <feImage xlink:href="#activeRect" preserveAspectRatio="none" />
            <feMerge> 
                <feMergeNode />
                <feMergeNode in="SourceGraphic"/>
            </feMerge>
        </filter>
    </defs>
    <g class="clientMonitor" transform="translate(350,180) scale(1.5)">
        <g class="build">
            <path class="UserScreen" style="filter:url(#dropshadow)" 
                fill="#fff8dc" stroke="#222" stroke-width="1.33"
                d="M-100,-60 h200 v120 h-200 z
                m4,6 v108 h192 v-108 z
                M-110,80 h5 
                    v-3 h12 v3 h3 
                    v-3 h7 v3 h3 
                    v-3 h7 v3 h3 
                    v-3 h7 v3 h3 
                    v-3 h7 v3 h3 
                    v-3 h7 v3 h3 
                    v-3 h7 v3 h3 
                    v-3 h7 v3 h3 
                    v-3 h7 v3 h3 
                    v-3 h7 v3 h3 
                    v-3 h7 v3 h3 
                    v-3 h7 v3 h3 
                    v-3 h12 v3 
                    h5 v5 H-110 z
                M60,70 h30 v30 c0,7 -7,15 -15,15 c-8,0 -15,-8 -15,-15 z m15,0 v15"/>

            <path class="UserScreenContent"
                fill="#222" d="M-100,-60 m4,6 v108 h192 v-108 z"/>
        </g>

        <path class="UserSmiley build"
            fill="#ddc" stroke="#222" stroke-width="0.66"
            d="M0,-20 a20,20 0,0,0, 0,40 a20,20 0,0,0, 0,-40z 
                m-15,25 a16,10 0,0,0, 30,0
                m-7,-13 a3,3 0,1,0, 1,0 z
                m-16,0 a3,3 0,1,0, 1,0 z
                m8,-7 l8,-10 m-9,10 l2,-9"
            transform="translate(-110,-60) scale(2)" />

        <g class="build">
            <path class="ActionButton"
                fill="#acf" stroke="#fff" stroke-width="2"
                d="M-85,-22
                    a6,6 0,0,1 6,-6 h160 
                    a6,6 0,0,1 6,6 v40
                    a6,6 0,0,1 -6,6 h-160
                    a6,6 0,0,1 -6,-6 z" />
            <text class="ActionText" x="0" y="0">Action</text>
            <path class="MouseCursor"
                fill="#fff" stroke="#222"
                d="M0,0 l10,17 l-7,-2 l3,10 h-12 l3,-10 l-7,2 z"
                transform="translate(45,5) rotate(-40) scale(2)" />
        </g>
    </g>

    <g class="command build" transform="translate(700,140)">
        <path class="commandArrow" style="filter:url(#dropshadow)"
            fill="#fca" stroke="#222" stroke-width="2"
            d="M-150,0
                c-1,-1.66 -.66,-5 1,-6
                c30,-20 145,-60 200,-50
                c2.5,.5 5,-2.5 5,-5 v-30
                c0,-5 3,-8 15,0 l120,80
                c3,2 3,6 0,8 l-120,80
                c-12,8 -15,5 -15,0 v-30
                c0,-2.5 -1,-5 -4.5,-6
                c-53,-7 -120,20 -150,40
                c-1.66,1 -4,.33 -5,-1.33 z"
            transform="rotate(8)" />
        <text class="commandText" x="0" y="0">Command</text>
    </g>

    <g class="server build" transform="translate(1050,150)">
        <path class="ServerBox" style="filter:url(#dropshadow)"
            fill="#fff8dc" stroke="#222" stroke-width="1"
            d="M-65,-25 h130 v100 h-130 z
                l15,-15 h130 v100 l-15,15
                m0,-100 l15,-15"
            transform="scale(2)" />

        <path class="ServerFilter build"
            fill="#acf" stroke="#222" stroke-width="2"
            d="M-30,-30
                a30,10 0,0,1 60,0 v10 l-25,25 v30 l-10,-10 v-20 l-25,-25 z
                m5,0 a25,6 0,0,0 50,0 a25,6 0,0,0 -50,0"
            transform="translate(-60,80)" />

        <path class="ServerStorage build"
            fill="#acf" stroke="#222" stroke-width="2"
            d="M-30,-30 
                a30,10 0,0,1 60,0 v60 
                a30,10 0,0,1 -60,0 z
               m60,0 a30,10 0,0,1 -60,0
               m60,15 a30,10 0,0,1 -60,0
               m60,15 a30,10 0,0,1 -60,0
               m60,15 a30,10 0,0,1 -60,0"
            transform="translate(60,80)" />

        <text class="ServerText" x="0" y="0">Server</text>
    </g>

    <g class="events build" transform="translate(1100, 450)">
        <path class="commandArrow" style="filter:url(#dropshadow)"
            fill="#fca" stroke="#222" stroke-width="2"
            d="M-150,0
                c-1,-1.66 -.66,-5 1,-6
                c30,-20 145,-60 200,-50
                c2.5,.5 5,-2.5 5,-5 v-30
                c0,-5 3,-8 15,0 l120,80
                c3,2 3,6 0,8 l-120,80
                c-12,8 -15,5 -15,0 v-30
                c0,-2.5 -1,-5 -4.5,-6
                c-53,-7 -120,20 -150,40
                c-1.66,1 -4,.33 -5,-1.33 z"
            transform="rotate(140)" />
        
        <text class="commandText" x="-50" y="40">Events</text>
    </g>

    <g class="compute build" transform="translate(825, 575)">
        <path class="ComputeBox" style="filter:url(#dropshadow)"
            fill="#fff8dc" stroke="#222" stroke-width="2"
            d="M-120,-80 h240 v160 h-240 z" />
        <path class="ComputeSum"
            fill="#acf" stroke="#222" stroke-width="3"
            d="M-55,-65
                h100 l10,40 h-7 l-3,-5 c-8,-14 -10,-20 -32,-20 h-50
                l45,45 l-40,40
                h45 c12,0 24,-4 32,-20 l3,-5 h7 l-12,50 h-98
                v-15 l40,-40 l-40,-40 z"
            transform="scale(0.66) translate(0,30)" />
        
        <text class="ViewText" x="0" y="-50">Computations</text>
    </g>

    <g class="updates build" transform="translate(530, 500)">
        <path class="commandArrow" style="filter:url(#dropshadow)" 
            fill="#fca" stroke="#222" stroke-width="2"
            d="M-150,0
                c-1,-1.66 -.66,-5 1,-6
                c30,-20 145,-60 200,-50
                c2.5,.5 5,-2.5 5,-5 v-30
                c0,-5 3,-8 15,0 l120,80
                c3,2 3,6 0,8 l-120,80
                c-12,8 -15,5 -15,0 v-30
                c0,-2.5 -1,-5 -4.5,-6
                c-53,-7 -120,20 -150,40
                c-1.66,1 -4,.33 -5,-1.33 z"
            transform="scale(-1,1) rotate(0)" />
        
        <text class="commandText" x="-20" y="0">Updates</text>
    </g>

    <g class="views build" transform="translate(170, 550) scale(1.5)">
        <path class="ViewScreen" style="filter:url(#dropshadow)"
            fill="#fff8dc" stroke="#222" stroke-width="1.33"
            d="M-100,-60 h200 v120 h-200 z
               m4,6 v108 h192 v-108 z
               M-5,60 v10 h-20 v5 h50 v-5 h-20 v-10 z"/>

        <path class="ViewScreenContent"
            fill="#222" d="M-100,-60 m4,6 v108 h192 v-108 z"/>

        <path class="ViewTree build"
            fill="#222" stroke="#fff" stroke-width="2.5"
            d="M-50,-50
                m3,0 h10 a3,3 0,0,1 3,3 v10 a3,3 0,0,1 -3,3 h-10 a3,3 0,0,1 -3,-3 v-10 a3,3 0,0,1 3,-3 z
                m0,8 h10
                m10,-6 h60 v12 h-60 z
               M-42,-30 v12 m0,5 v12 m0,5 v12 m0,5 v8 h10
                m5,-8 h10 a3,3 0,0,1 3,3 v10 a3,3 0,0,1 -3,3 h-10 a3,3 0,0,1 -3,-3 v-10 a3,3 0,0,1 3,-3 z
                m0,8 h10 m-5,-5 v10
                m15,-11 h35 v12 h-35 z
               M-42,-24 h10
                m5,-8 h10 a3,3 0,0,1 3,3 v10 a3,3 0,0,1 -3,3 h-10 a3,3 0,0,1 -3,-3 v-10 a3,3 0,0,1 3,-3 z
                m0,8 h10
                m10,-6 h30 v12 h-30 z
               M-22,-12 v12 m0,5 v7 h10
                m5,-6 h25 v12 h-25 z
               M-22,-6 h10
                m5,-6 h40 v12 h-40 z"
            transform="translate(-40,5) scale(0.9)" />

        <path class="ViewGraph build"
            fill="#222" stroke="#fff" stroke-width="2.5"
            d="M-40,40 v-50 h20 v50 z
               m25,0 v-70 h20 v70 z
               m25,0 v-60 h20 v60 z"
            transform="translate(50,0)" />
        
        <text class="ViewText" x="0" y="-90">Views</text>
    </g>

</svg> 
++++


[.subtitle]
== Data Schema

[.cue]
****
Where did I hear that before?
****

== Examples

[%build]
* XML schema
* JSON schema
* data definition language (DDL)

[.cue]
****
Schemas are everywhere.

They describe how our data is organised
These are essential part of a distributed system.

* We can derive how to store our data
* And we can derive how to communicate
****

== !

image::Geburtstag.jpg[role="center", width="1920"]

[.cue]
****
We have now everything to try this with C++ and Qt

* Strong Types
* Distributed System: Commands, Events, Protocols,
* data schema
****


[.subtitle]
== Schema with C++ types

[.cue]
****
Let's start with the basics.

How can we express our data schema in C++.
****

[.source]
== !

[.build]
--
[source%nested, cpp]
----
// schema primitives:
// nest++
template<class...> struct AllOf {}; // struct
// nest--
// nest++
template<class...> struct OneOf {}; // variant
// nest--
// nest++
template<class...> struct SomeOf {}; // ???
// nest--

// nest++
template<class Id, class>
struct EntitySet {};
// nest--
// nest++
template<class Id, class Node, class Leaf>
struct OrderedTree {};
// nest--
----
--

[.cue]
****
Notice these are all empty structures.

Our tree is customized to our special needs.

Ok, simple enough let's use these types for an example:
****

[.source.s62x16]
== !

[.build]
--
[source%nested, cpp]
----
// example usage:
// nest++
using PersonId = Strong<int, struct PersonIdTag>;
// nest--
// nest++
using Name = Strong<string, struct VornameTag>;
// nest--
// nest++
enum class Role { Unknown, Teacher, Student };
// nest--

// nest++
using PersonData = AllOf<Name, Role>;
// nest--

// nest++
using Persons = EntitySet<PersonId, PersonData>;
// nest--
----
--

[.cue]
****
Let's store some basic person data

We use concrete and unique value types to store properties.

Instead of structures and containers we use our schema primitives.

Let's do a sketch, how we intend to use these:
****

[.source.s62x16]
== !

[.build]
--
[source%nested, cpp]
----
// nest++
void testPersonCreate() {
    // nest++
    auto repo = ToRepository<Persons>{};
    // nest--

    // nest++
    auto cmd = EntityCreate<PersonData>{ 
        Name{"Bjarne Stroustrup"},
        Role::Teacher };
    // nest--

    // nest++
    to_command_processor<Persons>(cmd, repo);
    // nest--
}
// nest--
----
--

== Type driven [.green]#Code# generation

[.canvas]
image::grandValleyCattleDrive.jpg[]

== Our TODO List

[%build]
* [language-cpp]#`ToCommand<T>`#
* [language-cpp]#`ToRepository<T>`#
* [language-cpp]#`to_command_processor<T>`#
* Network-Protocols, GUI, …

[.cue]
****
* commands to manage our storage
* repositories to store and retrieve the data
* apply commands to repositories
* continue to profit with networking, GUIs and much more…

Ok, let's get to work:
* First try to do some simple transport storage of data for our create command.
****


== Simple storage

[.build]
* [language-cpp]#`ToStorage<T>`#

[.cue]
****
The data has to be simply be stored to not get lost.
****

[.source.s62x16]
== !

[source, cpp]
----
AllOf<Ts...> -> std::tuple<ToStorage<Ts>...>
----

[.source.s62x16]
== !

[source, cpp]
----
auto f(AllOf<Ts...>) -> std::tuple<ToStorage<Ts>...>;
----

[.source.s62x16]
== !

[.build]
--
[source%nested, cpp]
----
// nest++
// nest++
template<class T>
auto toStorage(T);
// nest--

// nest++
template<class T>
using Ptr = T*;
// nest--

template<class T>
using ToStorage = decltype(toStorage(Ptr<T>{}));
// nest--

template<class... Ts>
auto toStorage(AllOf<Ts...> *)
    -> std::tuple<ToStorage<Ts>...>;

// nest++
using Test = ToStorage<AllOf<>>; // error
// nest--
----
--

[.cue]
****
The idea: use function signatures to express type conversions recursively.
****

== We have a bit of an ordering problem…

""
…, unqualified name lookup takes place when the template definition is examined.
""
link:https://en.cppreference.com/w/cpp/language/unqualified_lookup#Template_definition[cppreference.com]

[.cue]
****
Symbols are not looked up on instantiation but on template definition.

Luckily we have ADL in C++:
****

== ADL for the rescue!

""
(in other words, adding a new function declaration after template definition does not make it visible except via ADL)
""
link:https://en.cppreference.com/w/cpp/language/unqualified_lookup#Template_definition[cppreference.com]

[.cue]
****
As long as arguments are in the same namespace functions are found.

Yeah!

Now fix our simple storage with that…
****

[.source.s62x16]
== !

[.build]
--
[source%nested, cpp]
----
// Storage with ADL
// nest++
namespace storage {

// nest++
struct ADL {};
// nest--

// nest++
template<class T>
using ToStorage = decltype(toStorage(ADL{}, Ptr<T>{}));
// nest--

// nest++
template<class... Ts>
auto toStorage(ADL, AllOf<Ts...> *)
    -> std::tuple<ToStorage<Ts>...>;
// nest--

// nest++
// …
// nest--
} // namespace storage
// nest--
----
--

[.cue]
****
We add a namespace around everything.

* The ADL wrapper ensures everything in that namespace is found.
* ToStorage now can use an unknown function.

Let's fill in the remaining concepts:
****

[.source.s62x16]
== !

[.build]
--
[source%nested, cpp]
----
template<class... Ts>
auto toStorage(ADL, AllOf<Ts...> *)
    -> std::tuple<ToStorage<Ts>...>;

// nest++
template<class... Ts>
auto toStorage(ADL, OneOf<Ts...> *)
// nest++
    -> std::variant<ToStorage<Ts>...>;
// nest--
// nest--

// nest++
template<class Id, class Data>
auto toStorage(ADL, EntitySet<Id, Data> *)
// nest++
    -> std::vector<std::tuple<Id, ToStorage<Data>>>;
// nest--
// nest--
----
--

[.cue]
****
AllOf means all the given types are stored
std::tuple seems perfect for this job.
For every type we derive the storage type recursively.

OneOf wants us to store exactly one of the types
std::variant seems to be made for this

EntitySet stores any amount of entities indexed by id.
A vector storing a tuple does this job quite well.

So you see the pattern for schema concepts?

Now we also need to handle our value types.
****

[.source.s62x16]
== !

[.build]
--
[source%nested, cpp]
----
// storage for values
// nest++
template<class T>
constexpr bool isValue() {
// nest++
    if constexpr (std::is_class_v<T>) 
        return !std::is_empty_v<T>;
// nest--
// nest++
    else
        return std::is_enum_v<T>;
// nest--
}
// nest--

// nest++
template<class T>
auto toStorage(ADL, T *)
    -> std::enable_if_t<isValue<T>(), T>;
// nest--
----
--

[.cue]
****
First we have to distinguish our value types from the schema types.

A class or struct is used for strong types. 
But those are unlike our schema primitives not empty.
We also use enums direcly as property types.
Everything else is not consided value type here.

All value types can basically store themselfs.

The only concept missing now is our tree:
****

[.source.s62x16]
== !

[.build]
--
[source%nested, cpp]
----
// Storage for OrderedTree
// nest++
// nest++
// nest++
template<class Id>
using ParentId = StrongAddTag<Id, struct ParentIdTag>;
// nest--

template<class Id, class Node, class Leaf>
using TreeNode = std::tuple<
// nest++
    Id, ParentId<Id>,
// nest--
// nest++
    std::variant<ToStorage<Node>, ToStorage<Leaf>>
// nest--
    >;
// nest--

template<class Id, class Node, class Leaf>
auto toStorage(ADL, OrderedTree<Id, Node, Leaf> *)
    -> std::vector<TreeNode<Id, Node, Leaf>>;
// nest--
----
--

[.cue]
****
For a tree we have to store the parent relationship.

Apart from that it works like the Entity Set.

Simple?
****

== Commands

[.build]
* [.green]#✔# [language-cpp]#`ToStorage<T>`#
* [language-cpp]#`ToCommand<T>`#

[.cue]
****
Commands are applied to Repositories to change the current state.

We apply the same pattern as for storage.
The ADL boilerplate is left out of the slides.

Lets start with the EntitySet:
****

[.source.s62x16]
== !

[.build]
--
[source%nested, cpp]
----
// nest++
template<class Data>
using EntityCreate = ToStorage<Data>;
// nest--
// nest++
template<class Id>
using EntityDestroy = Id;
// nest--
// nest++
template<class Id, class Data>
using EntityUpdate = std::tuple<Id, ToCommand<Data>>;
// nest--

template<class Id, class Data>
auto toCommand(ADL, EntitySet<Id, Data> *)
// nest++
    -> std::variant<
      // nest++
        EntityCreate<Data>,
      // nest--
      // nest++
        EntityDestroy<Id>>;
      // nest--
      // nest++
        EntityUpdate<Id, Data>,
      // nest--
// nest--
----
--

[.cue]
****
What kind of commands to we need?

* Create uses our storage
* Destroy just refers to the item to destroy
* Update identifies one Entity and stores a command on them.

Only Update is recursive!

Simple enough - next up: Tree commands
****

[.source.s90x23]
== !

[.build]
--
[source%nested, cpp]
----
// Commands for OrderedTree
// nest++
template<class Id, class Node, class Leaf>
using TreeCreate = std::tuple<
// nest--
// nest++
    ParentId<Id>, BeforeId<Id>, ToStorage<OrderedTree<Id, Node, Leaf>>>;
// nest--
// nest++
template<class Id>
using TreeDestroy = Id;
// nest--
// nest++
template<class Id, class Node, class Leaf>
using TreeUpdate = std::tuple<
// nest--
// nest++
    Id, std::variant<ToCommand<Node>, ToCommand<Leaf>>>;
// nest--
// nest++
template<class Id>
using TreeMove = std::tuple<Id, ParentId<Id>, BeforeId<Id>>;
// nest--

// nest++
template<class Id, class Node, class Leaf>
auto toCommand(ADL, OrderedTree<Id, Node, Leaf> *)
// nest++
    -> std::variant<
      // nest++
        TreeCreate<Id, Node, Leaf>,
      // nest--
      // nest++
        TreeUpdate<Id, Node, Leaf>,
      // nest--
      // nest++
        TreeMove<Id>, TreeDestroy<Id>>;
      // nest--
// nest--
// nest--
----
--

[.cue]
****
Just a notch more complex.

* Create we have to know where in the tree we add a subtree.
* Destroy just identifies the tree node to destroy.
* Update identifies a node and what command to apply there.
* TreeMove allows to move nodes inside the tree.
****

== Repository

[.build]
* [.green]#✔# [language-cpp]#`ToStorage<T>`#
* [.green]#✔# [language-cpp]#`ToCommand<T>`#
* [language-cpp]#`ToRepository<T>`#

[.cue]
****
Now we have the commands, now we need repositories.
****

[.source.s62x16]
== !

[.build]
--
[source%nested, cpp]
----
template<class Id, class Data>
auto toRepository(ADL, EntitySet<Id, Data> *)
// nest++
    -> std::map<Id, ToRepository<Data>>;
// nest--
----
--

[.cue]
****
This is enough.

But I recommend to build testable classes for this.
****

[.source.s62x16]
== !

[.build]
--
[source%nested, cpp]
----
template<class Id, class Data>
class EntityRepository {
    std::map<Id, ToRepository<Data>> m;

public:
    // nest++
    auto operator[] (Id) -> ToRepository<Data>&;
    // nest--
    // nest++
    void create(const ToStorage<Data>&);
    // nest--
    // nest++
    void destroy(Id);
    // nest--
};

// nest++
template<class Id, class Data>
auto toRepository(ADL, EntitySet<Id, Data> *)
// nest--
// nest++
    -> EntityRepository<Id, Data>;
// nest--
----
--

[.cue]
****
You see the commands that are available as member functions.
****

== Processing Commands

[.build]
* [.green]#✔# [language-cpp]#`ToStorage<T>`#
* [.green]#✔# [language-cpp]#`ToCommand<T>`#
* [.green]#✔# [language-cpp]#`ToRepository<T>`#
* [language-cpp]#`to_command_processor<T>`#

[.cue]
****
Now we are ready to apply commands to repositories.
****

== !

Command ∘ Repository -> Updated Repository

[.cue]
****
The repositories already implement all the functionality.
We just have to connect it to the schema.

This time we generate functionality instead of types.
To keep the same pattern, we use lambdas for that:
****

[.source.s77x19]
== !

[.build]
--
[source%nested, cpp]
----
// Processor boilerplate
namespace processor {

// nest++
struct ADL {};
// nest--

// nest++
template<class T>
constexpr auto to_command_processor = toCommandProcessor(ADL, Ptr<T>{});
// nest--

} // namespace processor
----
--

[.cue]
****
We still use an ADL wrapper.

toCommandProcessor returns a lambda.
The lambda expects a command and a mutable repository reference

Until C++20 Lambdas cannot be instantiated, so we use a constexpr constant.

Let's look at the implementation for EntitySet
****

[.source.s77x19]
== !

[.build]
--
[source%nested, cpp]
----
template<class Id, class Data>
constexpr auto toCommandProcessor(ADL, EntitySet<Id, Data> *) {
    // nest++
    using T = EntitySet<Id, Data>;
    return [](const ToCommand<T>& cmd, 
              ToRepository<T>& repo) {
        // nest++
        oneVisit(cmd,
            // nest++
            [&repo](const ToStorage<Data>& storage) {
                repo.create(storage);
            },
            // nest--
            // nest++
            [&repo](Id id) {
                repo.destroy(id);
            });
            // nest--
            // nest++
            [&repo](const std::tuple<Id, ToCommand<Data>>& update) {
                auto [id, dataCmd] = update;
                to_command_processor<Data>(dataCmd, repo[id]);
            },
            // nest--
        // nest--
    };
    // nest--
}
----
--

[.cue]
****
We create a lambda with the expected signature.
Depending on the actual command we call the repository function.
****

== Current Scores

[%build]
* [.green]#✔# [language-cpp]#`ToStorage<T>`#
* [.green]#✔# [language-cpp]#`ToCommand<T>`#
* [.green]#✔# [language-cpp]#`ToRepository<T>`#
* [.green]#✔# [language-cpp]#`to_command_processor<T>`#

== What now?

[%build]
* Network-Protocols
* Computations
* GUI

[.cue]
****
Protocols - work just as seen before.
Computations - basically compute new values from existing data.

Let's look deeper into GUIs with Qt.
****


== Qt - Gui

[%build]
* Qt moc - Meta Object Compiler
* link:https://github.com/woboq/verdigris/issues[Woboq Verdigris]
* … with new APIs

[.cue]
****
Moc Compiler would require a lot of work.

Verdigris from Woboq is a huge win.
****


[.source.s77x19]
== !

[.build]
--
[source%nested, cpp]
----
// nest++
// nest++
template<class... Ts>
class TupleView : public QObject {
  W_OBJECT(TupleView)

  // nest++
  // nest++
  template<size_t I, class = std::enable_if_t<(I < sizeof...(Ts))>>
  struct RegisterProperties {
    constexpr static auto property = 
      // nest++
      w_cpp::makeProperty<QVariant>(property_name<I>, qvariant_name)
        // nest--
        // nest++
        .setGetter(&TupleView::getPropertyValue<I>)
        .setSetter(&TupleView::setPropertyValue<I>)
        .setNotify(&TupleView::propertyChanged<I>);
        // nest--
  };
  // nest--
  W_CPP_PROPERTY(RegisterProperties)
  // nest--
};
// nest--

template<class... Ts>
auto toViewModel(ADL, AllOf<Ts...> *) -> TupleView<Ts...>;
// nest--
----
--



== Templated QObject

TODO


== Summary

[.build]
* one central type driven data schema
* guides everything else

== &plus;+ Advantages &plus;+ &nbsp;

[%build]
* central schema definition
* tailored to domain
* split up data and logic
* very good testability

== \-- Disadvantages \--

[%build]
* uncommon + learning curve
* C++ requires some boilerplate
* long type names

== Usage Scenarios

[%build]
* long lived distributed systems
* performance critical systems

== Links

[%build]
* link:https://github.com/woboq/verdigris[github.com/woboq/verdigris]
* link:https://github.com/basicpp17[github.com/basicpp17]

== !

image::andreas.png[role="center", width="400"]

&nbsp;

[%build]
* Andreas Reischuck
* @*arBmind*

[.cue]
****
Schulungen

C++ - Qt - Clean Code
****

== !

image::hicknhackLogo_new_text.png[role="center", width="400"]

&nbsp;

[.green]_Work_ with us…

[.cue]
****
* C++ Qt UIs
* Dresden
****

== !

image::cppug.png[role="pull-right", width="550"]

&nbsp;

Give a [.green]*Talk* +
=> get a *Dresden* tour

[.cue]
****
* Video Recording
* personal city tour
* I visit your local usergroup
****

== !

image::rebuild_logo.png[role="pull-left", width="450"]

*Rebuild* language project

[.bigger]
&nbsp;

[.center]
[.green]__Collaborate__

[.cue]
****
* improved language & tools for everybody
* Compiler built with C++17
****

== Try out *more*!

== Try out *Type* Driven *Development*!

== Photo Credits

[.small]
* link:https://www.flickr.com/photos/purpleseadonkey/4775066884[Explosion] link:https://creativecommons.org/licenses/by/2.0/[(cc-by-license)]

[.subtitle]
== Thank you!

[language-cpp]#`co_await question_ready()`#

== Opaque Strong Types

[.source.s62x16]
== !

[.build]
--
[source%nested, cpp]
----
// nest++
// nest++
struct PersonId;
// nest--
// nest++
constexpr auto makeOpaque(Strong<int, struct PersonIdTag>)
    -> PersonId;
// nest--

struct PersonId : Strong<int, struct PersonIdTag> {
    // nest++
    using Strong::Strong;
    // nest--
};
// nest--
----
--

[.source.s62x16]
== !

[.build]
--
[source%nested, cpp]
----
#define STRONG_OPAQUE(name, type, ...)          \
    struct name;                                \
    constexpr auto makeOpaqueType               \
        (Strong<type, ##__VA_ARGS__>) -> name;  \
    struct name : Strong<type, ##__VA_ARGS__> { \
        using Strong::Strong;                   \
    }

STRONG_OPAQUE(PersonId, int);
----
--

== Join Type Packs

[.source.s62x16]
== !

[.build]
--
[source%nested, cpp]
----
template <class... As, class... Bs>
auto join(AllOf<As...>, AllOf<Bs...>)
    -> AllOf<As...,Bs...>;

template<class A, class B>
using Join = decltype(
    join(std::declval<A>(), std::declval<B>())
);
----
--

== OneVisit

[.source.s62x16]
== !

[.build]
--
[source%nested, cpp]
----
// nest++
// nest++
template<class... Fs> struct Overloaded : Fs... {
    using Fs::operator()...;
};
// nest--
// nest++
template<class... Fs> Overloaded(Fs...) 
    -> Overloaded<Fs...>;
// nest--

template<class V, class... Fs>
auto oneVisit(V &&v, Fs &&... fs) {
// nest++
    return std::visit(Overloaded{fs...}, v);
// nest--
}
// nest--
----
--
